// Generated by CoffeeScript 1.9.3
var ALERT_MULTIPLE, MAX_VALUE, NUM_OF_LAST_DURATIONS, NUM_OF_MOST_EXTREME, NUM_OF_REQUESTS, REQUEST_TYPES, TIMEOUT, addDuration, asyncLib, executeRequests, findMedianRecord, requestLib, runChecks, urlLib, urlencodedParserLib, validUrlLib;

ALERT_MULTIPLE = 2;

MAX_VALUE = 100000;

NUM_OF_LAST_DURATIONS = 7;

NUM_OF_MOST_EXTREME = 10;

NUM_OF_REQUESTS = 5;

REQUEST_TYPES = {
  'GET': true,
  'POST': true
};

TIMEOUT = 10000;

asyncLib = require('async');

requestLib = require('request');

urlencodedParserLib = require('body-parser').urlencoded({
  extended: false
});

urlLib = require('url');

validUrlLib = require('valid-url');

module.exports = function(app) {
  app.get('/', function(req, res) {
    var collection, db;
    db = req.db;
    collection = db.get('alldurations');
    return collection.find({}, {}, function(e, durations) {
      var context;
      context = {
        'durations': durations,
        'NUM_OF_LAST_DURATIONS': NUM_OF_LAST_DURATIONS
      };
      return res.render('index.ejs', context);
    });
  });
  app.post('/add', urlencodedParserLib, function(req, res) {
    var collection, data, db, type, url;
    url = req.body.url;
    type = req.body.type;
    data = req.body.data;
    if (!validUrlLib.isUri(url)) {
      res.status(500).send('newURLErrorURL');
      return;
    }
    if (!REQUEST_TYPES[type]) {
      res.status(500).send('newURLErrorType');
      return;
    }
    if (data) {
      try {
        JSON.parse(data);
      } catch (_error) {
        res.status(500).send('newURLErrorData');
        return;
      }
    }
    db = req.db;
    collection = db.get('alldurations');
    return collection.findOne({
      url: url
    }, function(error, result) {
      var urlEntry;
      if (error) {
        res.status(500).send('newURLErrorSave');
        return;
      }
      if (result) {
        res.status(500).send('newURLErrorDuplicate');
        return;
      }
      urlEntry = {
        url: url,
        type: type,
        data: data,
        durations: []
      };
      return collection.insert(urlEntry, function(error, result) {
        if (error) {
          res.status(500).send('newURLErrorSave');
          return;
        }
        return res.sendStatus(200);
      });
    });
  });
  app.get('/run', function(req, res) {
    var db, timestamp;
    timestamp = Math.floor(new Date() / 1000);
    runChecks(req.db, timestamp);
    res.sendStatus(200);
    return db = req.db;
  });
  return app.get('/dashboard', function(req, res) {
    var collection, db;
    db = req.db;
    collection = db.get('metrics');
    return collection.findOne({
      metric: 'duration'
    }, function(error, slowestDurations) {
      if (error) {
        console.log('ERROR: the database could not be accessed');
      }
      return collection.findOne({
        metric: 'variance'
      }, function(error, mostVaryingDurations) {
        var context;
        if (error) {
          console.log('ERROR: the database could not be accessed');
        }
        context = {
          slowestDurations: slowestDurations,
          mostVaryingDurations: mostVaryingDurations
        };
        return res.render('dashboard.ejs', context);
      });
    });
  });
};

runChecks = function(db, timestamp) {
  var metrics;
  metrics = db.get('metrics');
  return asyncLib.series(['duration', 'variance'].map(function(metric) {
    return function(callback) {
      return metrics.findOne({
        metric: metric
      }, function(error, recordsObject) {
        if (error) {
          console.log('ERROR: the database could not be updated');
          return;
        }
        recordsObject['records'] = [];
        recordsObject['min'] = MAX_VALUE;
        metrics.update({
          _id: recordsObject['_id']
        }, recordsObject);
        return callback(null);
      });
    };
  }), function(err, results) {
    var collection;
    collection = db.get('alldurations');
    return collection.find({}, {}, function(e, durations) {
      return asyncLib.series(durations.map(function(duration) {
        return function(callbackOuter) {
          var data, options, requestCallerFunction, requestType, url;
          url = duration['url'];
          options = {
            uri: url,
            time: true,
            timeout: TIMEOUT
          };
          requestType = duration['type'];
          if (requestType === 'GET') {
            requestCallerFunction = function(requestCallerCallback) {
              return requestLib(options, requestCallerCallback);
            };
          } else if (requestType === 'POST') {
            data = duration['data'];
            requestCallerFunction = function(requestCallerCallback) {
              return requestLib.post(options, data, requestCallerCallback);
            };
          }
          return executeRequests(requestCallerFunction, db, url, timestamp, callbackOuter);
        };
      }));
    });
  });
};

executeRequests = function(requestCallerFunction, db, uri, timestamp, callbackOuter) {
  var i, responseRecords, results1;
  responseRecords = [];
  return asyncLib.series((function() {
    results1 = [];
    for (var i = 1; 1 <= NUM_OF_REQUESTS ? i <= NUM_OF_REQUESTS : i >= NUM_OF_REQUESTS; 1 <= NUM_OF_REQUESTS ? i++ : i--){ results1.push(i); }
    return results1;
  }).apply(this).map(function(_) {
    return function(callbackInner) {
      return requestCallerFunction(function(error, response, body) {
        var responseRecord;
        if (error) {
          responseRecord = {
            time: null
          };
        } else {
          responseRecord = {
            time: response.elapsedTime,
            statusCode: response.statusCode,
            length: body.length
          };
        }
        responseRecords.push(responseRecord);
        if (responseRecords.length === NUM_OF_REQUESTS) {
          addDuration(db, uri, responseRecords, timestamp);
          responseRecords = [];
        }
        return callbackInner(null);
      });
    };
  }), function(err, results) {
    return callbackOuter(null);
  });
};

addDuration = function(db, url, responseRecords, timestamp) {
  var allDurations, currentDuration, responseRecord;
  responseRecord = findMedianRecord(responseRecords);
  currentDuration = responseRecord['time'];
  console.log(url);
  console.log(responseRecords);
  console.log(currentDuration);
  console.log(responseRecord);
  allDurations = db.get('alldurations');
  return allDurations.findOne({
    url: url
  }, function(error, durationsObject) {
    var average, countDurations, durationObject, i, lastDurations, len, metricStrings, metricValues, metrics, newDuration, sumDurations, variance;
    if (error) {
      console.log('ERROR: the database could be updated');
      return;
    }
    average = durationsObject['lastDurationsAverage'];
    if (average * ALERT_MULTIPLE < currentDuration) {
      console.log("ALERT FIRED: " + url + " request duration of " + currentDuration + " exceeded the last " + NUM_OF_LAST_DURATIONS + "-check average of " + average + " more than " + ALERT_MULTIPLE + " times");
    }
    newDuration = {};
    newDuration[timestamp] = responseRecord;
    durationsObject['durations'].push(newDuration);
    durationsObject['lastDurations'] = durationsObject['durations'].slice(-NUM_OF_LAST_DURATIONS);
    lastDurations = durationsObject['lastDurations'];
    sumDurations = 0;
    countDurations = 0;
    for (i = 0, len = lastDurations.length; i < len; i++) {
      durationObject = lastDurations[i];
      for (timestamp in durationObject) {
        responseRecord = durationObject[timestamp];
        if (responseRecord['time']) {
          sumDurations += responseRecord['time'];
          countDurations++;
        }
      }
    }
    durationsObject['lastDurationsAverage'] = sumDurations / countDurations;
    allDurations.update({
      _id: durationsObject['_id']
    }, durationsObject);
    variance = currentDuration / durationsObject['lastDurationsAverage'];
    metricStrings = ['duration', 'variance'];
    metricValues = [currentDuration, variance];
    metrics = db.get('metrics');
    return [0, 1].map(function(metricIndex) {
      var metricString, metricValue;
      metricString = metricStrings[metricIndex];
      metricValue = metricValues[metricIndex];
      return metrics.findOne({
        metric: metricString
      }, function(error, recordsObject) {
        var index, j, len1, min, newMin, newRecord, record, ref;
        if (error) {
          console.log('ERROR: the database could not be updated');
          return;
        }
        min = recordsObject['min'];
        newRecord = {
          url: url
        };
        newRecord[metricString] = metricValue;
        if (recordsObject['records'].length < NUM_OF_MOST_EXTREME && metricValue) {
          recordsObject['records'].push(newRecord);
          if (min > metricValue) {
            recordsObject['min'] = metricValue;
          }
        } else {
          if (min < metricValue) {
            newMin = MAX_VALUE;
            ref = recordsObject['records'];
            for (index = j = 0, len1 = ref.length; j < len1; index = ++j) {
              record = ref[index];
              if (record[metricString] === min) {
                recordsObject['records'][index] = newRecord;
              }
              if (newMin > recordsObject['records'][index][metricString]) {
                newMin = recordsObject['records'][index][metricString];
              }
            }
            recordsObject['min'] = newMin;
          }
        }
        console.log(recordsObject);
        return metrics.update({
          _id: recordsObject['_id']
        }, recordsObject);
      });
    });
  });
};

findMedianRecord = function(responseRecords) {
  var middle;
  responseRecords.sort(function(a, b) {
    return a.time - b.time;
  });
  middle = Math.floor(responseRecords.length / 2);
  return responseRecords[middle];
};

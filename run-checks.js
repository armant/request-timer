// Generated by CoffeeScript 1.9.3
var ALERT_MULTIPLE, NUM_OF_LAST_RUNS, NUM_OF_REQUESTS, TIMEOUT, addDuration, asyncLib, executeRequests, findMedianRecord, requestLib, runChecks;

ALERT_MULTIPLE = 2;

NUM_OF_LAST_RUNS = 7;

NUM_OF_REQUESTS = 5;

TIMEOUT = 10000;

asyncLib = require('async');

requestLib = require('request');

exports.run = function(req, res) {
  runChecks(req.db);
  return res.redirect('/');
};

runChecks = function(db) {
  var byTimestamp, byUrl;
  byUrl = db.get('byUrl');
  byTimestamp = db.get('byTimestamp');
  return byUrl.find({}, {}, function(e, urlRecords) {
    var timestamp, timestampRecord;
    timestamp = "" + (new Date().getTime());
    timestampRecord = {
      timestamp: timestamp,
      responseRecords: [],
      urlCount: urlRecords.length
    };
    byTimestamp.insert(timestampRecord);
    return asyncLib.series(urlRecords.map(function(urlRecord) {
      return function(callbackOuter) {
        var data, headers, options, requestCallerFunction, requestType, url;
        url = urlRecord['url'];
        requestType = urlRecord['type'];
        headers = urlRecord['headers'];
        data = urlRecord['data'];
        options = {
          uri: url,
          time: true,
          timeout: TIMEOUT
        };
        if (headers) {
          options['headers'] = headers;
        }
        if (requestType === 'GET') {
          requestCallerFunction = function(requestCallerCallback) {
            return requestLib(options, requestCallerCallback);
          };
        } else if (requestType === 'POST') {
          requestCallerFunction = function(requestCallerCallback) {
            return requestLib.post(options, data, requestCallerCallback);
          };
        }
        return executeRequests(requestCallerFunction, db, url, requestType, headers, data, timestamp, callbackOuter);
      };
    }));
  });
};

executeRequests = function(requestCallerFunction, db, url, requestType, headers, data, timestamp, callbackOuter) {
  var i, responseRecords, results1;
  responseRecords = [];
  return asyncLib.series((function() {
    results1 = [];
    for (var i = 1; 1 <= NUM_OF_REQUESTS ? i <= NUM_OF_REQUESTS : i >= NUM_OF_REQUESTS; 1 <= NUM_OF_REQUESTS ? i++ : i--){ results1.push(i); }
    return results1;
  }).apply(this).map(function(_) {
    return function(callbackInner) {
      return requestCallerFunction(function(error, response, body) {
        var responseRecord;
        responseRecord = {
          url: url,
          type: requestType,
          headers: headers,
          data: data,
          statusCode: -1,
          time: null,
          size: null,
          timestamp: timestamp
        };
        if (!error) {
          responseRecord['statusCode'] = response.statusCode;
          responseRecord['time'] = response.elapsedTime;
          responseRecord['size'] = body.length;
        }
        responseRecords.push(responseRecord);
        if (responseRecords.length === NUM_OF_REQUESTS) {
          addDuration(db, responseRecords, timestamp);
          responseRecords = [];
        }
        return callbackInner(null);
      });
    };
  }), function(err, results) {
    return callbackOuter(null);
  });
};

addDuration = function(db, responseRecords, timestamp) {
  var byTimestamp, byUrl, currentDuration, query, responseRecord;
  responseRecord = findMedianRecord(responseRecords);
  currentDuration = responseRecord['time'];
  byUrl = db.get('byUrl');
  query = {
    url: responseRecord['url'],
    type: responseRecord['type'],
    headers: responseRecord['headers'],
    data: responseRecord['data']
  };
  byUrl.findOne(query, function(error, durationsObject) {
    var i, lastDurations, len, previousSizeAverage, previousTimeAverage, recordCount, sumDurations, sumSizes, variance;
    if (error) {
      console.log('ERROR: the database could be updated');
      return;
    }
    previousTimeAverage = durationsObject['lastDurationsAverage'];
    previousSizeAverage = durationsObject['lastSizesAverage'];
    variance = (currentDuration / durationsObject['lastDurationsAverage']).toFixed(2);
    responseRecord['previousTimeAverage'] = previousTimeAverage;
    responseRecord['previousSizeAverage'] = previousSizeAverage;
    responseRecord['variance'] = variance;
    durationsObject['durations'].push(responseRecord);
    durationsObject['lastDurations'] = durationsObject['durations'].slice(-NUM_OF_LAST_RUNS);
    lastDurations = durationsObject['lastDurations'];
    sumDurations = 0;
    sumSizes = 0;
    recordCount = 0;
    for (i = 0, len = lastDurations.length; i < len; i++) {
      responseRecord = lastDurations[i];
      if (responseRecord['time'] && responseRecord['size']) {
        sumDurations += responseRecord['time'];
        sumSizes += responseRecord['size'];
        recordCount++;
      }
    }
    durationsObject['lastDurationsAverage'] = Math.floor(sumDurations / recordCount);
    durationsObject['lastSizesAverage'] = Math.floor(sumSizes / recordCount);
    return byUrl.update({
      _id: durationsObject['_id']
    }, durationsObject);
  });
  byTimestamp = db.get('byTimestamp');
  query = {
    timestamp: timestamp
  };
  return byTimestamp.findOne(query, function(error, timestampRecord) {
    if (error) {
      console.log('ERROR: the database could be updated');
      return;
    }
    timestampRecord['responseRecords'].push(responseRecord);
    return byTimestamp.update({
      _id: timestampRecord['_id']
    }, timestampRecord);
  });
};

findMedianRecord = function(responseRecords) {
  var middle;
  responseRecords.sort(function(a, b) {
    return a.time - b.time;
  });
  middle = Math.floor(responseRecords.length / 2);
  return responseRecords[middle];
};

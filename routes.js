// Generated by CoffeeScript 1.9.3
var ALERT_MULTIPLE, MAX_VALUE, NUM_OF_LAST_DURATIONS, NUM_OF_MOST_EXTREME, NUM_OF_REQUESTS, REQUEST_TYPES, TIMEOUT, addDuration, asyncLib, executeRequests, findMedianRecord, requestLib, runChecks, urlLib, urlencodedParserLib, validUrlLib;

ALERT_MULTIPLE = 2;

MAX_VALUE = 100000;

NUM_OF_LAST_DURATIONS = 7;

NUM_OF_MOST_EXTREME = 10;

NUM_OF_REQUESTS = 5;

REQUEST_TYPES = {
  'GET': true,
  'POST': true
};

TIMEOUT = 10000;

asyncLib = require('async');

requestLib = require('request');

urlencodedParserLib = require('body-parser').urlencoded({
  extended: false
});

urlLib = require('url');

validUrlLib = require('valid-url');

module.exports = function(app) {
  app.get('/stats-by-url', function(req, res) {
    var allDurations, db;
    db = req.db;
    allDurations = db.get('alldurations');
    return allDurations.find({}, {}, function(e, durations) {
      var durationsByTimestamp;
      durationsByTimestamp = db.get('durationsByTimestamp');
      return durationsByTimestamp.find({}, {}, function(e, byTimestamp) {
        var context;
        context = {
          'durations': durations,
          'NUM_OF_LAST_DURATIONS': NUM_OF_LAST_DURATIONS,
          'byTimestamp': byTimestamp
        };
        return res.render('by-url.ejs', context);
      });
    });
  });
  app.post('/add', urlencodedParserLib, function(req, res) {
    var allDurations, data, db, type, url;
    url = req.body.url;
    type = req.body.type;
    data = req.body.data;
    if (!validUrlLib.isUri(url)) {
      res.status(500).send('newURLErrorURL');
      return;
    }
    if (!REQUEST_TYPES[type]) {
      res.status(500).send('newURLErrorType');
      return;
    }
    if (data) {
      try {
        JSON.parse(data);
      } catch (_error) {
        res.status(500).send('newURLErrorData');
        return;
      }
    }
    db = req.db;
    allDurations = db.get('alldurations');
    return allDurations.findOne({
      url: url,
      type: type
    }, function(error, result) {
      var urlEntry;
      if (error) {
        res.status(500).send('newURLErrorSave');
        return;
      }
      if (result) {
        res.status(500).send('newURLErrorDuplicate');
        return;
      }
      urlEntry = {
        url: url,
        type: type,
        data: data,
        durations: []
      };
      return allDurations.insert(urlEntry, function(error, result) {
        if (error) {
          res.status(500).send('newURLErrorSave');
          return;
        }
        return res.sendStatus(200);
      });
    });
  });
  app.get('/run', function(req, res) {
    var timestamp;
    timestamp = "" + (Math.floor(new Date() / 1000));
    runChecks(req.db, timestamp);
    return res.redirect('/');
  });
  return app.get('/', function(req, res) {
    var allDurations, db;
    db = req.db;
    allDurations = db.get('alldurations');
    return allDurations.count({}, function(error, totalCount) {
      var metrics;
      metrics = db.get('metrics');
      return metrics.findOne({
        metric: 'duration'
      }, function(error, slowestDurations) {
        if (error) {
          console.log('ERROR: the database could not be accessed');
          return;
        }
        return metrics.findOne({
          metric: 'variance'
        }, function(error, mostVaryingDurations) {
          var context, progressPercentage;
          if (error) {
            console.log('ERROR: the database could not be accessed');
            return;
          }
          progressPercentage = Math.floor(Math.min(slowestDurations['records'].length, mostVaryingDurations['records'].length) / totalCount * 100);
          console.log(progressPercentage);
          context = {
            progressPercentage: progressPercentage,
            slowestDurations: slowestDurations,
            mostVaryingDurations: mostVaryingDurations
          };
          return res.render('dashboard.ejs', context);
        });
      });
    });
  });
};

runChecks = function(db, timestamp) {
  var metrics;
  metrics = db.get('metrics');
  return asyncLib.series(['duration', 'variance'].map(function(metric) {
    return function(callback) {
      return metrics.findOne({
        metric: metric
      }, function(error, recordsObject) {
        if (error) {
          console.log('ERROR: the database could not be updated');
          return;
        }
        recordsObject['records'] = [];
        recordsObject['min'] = MAX_VALUE;
        metrics.update({
          _id: recordsObject['_id']
        }, recordsObject);
        return callback(null);
      });
    };
  }), function(err, results) {
    var allDurations;
    allDurations = db.get('alldurations');
    return allDurations.find({}, {}, function(e, durations) {
      return asyncLib.series(durations.map(function(duration) {
        return function(callbackOuter) {
          var data, options, requestCallerFunction, requestType, url;
          url = duration['url'];
          options = {
            uri: url,
            time: true,
            timeout: TIMEOUT
          };
          requestType = duration['type'];
          if (requestType === 'GET') {
            requestCallerFunction = function(requestCallerCallback) {
              return requestLib(options, requestCallerCallback);
            };
          } else if (requestType === 'POST') {
            data = duration['data'];
            requestCallerFunction = function(requestCallerCallback) {
              return requestLib.post(options, data, requestCallerCallback);
            };
          }
          return executeRequests(requestCallerFunction, db, url, requestType, timestamp, callbackOuter);
        };
      }));
    });
  });
};

executeRequests = function(requestCallerFunction, db, url, requestType, timestamp, callbackOuter) {
  var i, responseRecords, results1;
  responseRecords = [];
  return asyncLib.series((function() {
    results1 = [];
    for (var i = 1; 1 <= NUM_OF_REQUESTS ? i <= NUM_OF_REQUESTS : i >= NUM_OF_REQUESTS; 1 <= NUM_OF_REQUESTS ? i++ : i--){ results1.push(i); }
    return results1;
  }).apply(this).map(function(_) {
    return function(callbackInner) {
      return requestCallerFunction(function(error, response, body) {
        var responseRecord;
        if (error) {
          responseRecord = {
            time: null
          };
        } else {
          responseRecord = {
            url: url,
            type: requestType,
            time: response.elapsedTime,
            statusCode: response.statusCode,
            length: body.length
          };
        }
        responseRecords.push(responseRecord);
        if (responseRecords.length === NUM_OF_REQUESTS) {
          addDuration(db, url, requestType, responseRecords, timestamp);
          responseRecords = [];
        }
        return callbackInner(null);
      });
    };
  }), function(err, results) {
    return callbackOuter(null);
  });
};

addDuration = function(db, url, requestType, responseRecords, timestamp) {
  var allDurations, currentDuration, durationsByTimestamp, responseRecord;
  responseRecord = findMedianRecord(responseRecords);
  currentDuration = responseRecord['time'];
  console.log(url);
  console.log(responseRecords);
  console.log(responseRecord);
  allDurations = db.get('alldurations');
  allDurations.findOne({
    url: url,
    type: requestType
  }, function(error, durationsObject) {
    var average, countDurations, durationObject, i, lastDurations, len, metricStrings, metricValues, metrics, newDuration, sumDurations, variance;
    if (error) {
      console.log('ERROR: the database could be updated');
      return;
    }
    average = durationsObject['lastDurationsAverage'];
    if (average * ALERT_MULTIPLE < currentDuration) {
      console.log("ALERT FIRED: " + url + " request duration of " + currentDuration + " exceeded the last " + NUM_OF_LAST_DURATIONS + "-check average of " + average + " more than " + ALERT_MULTIPLE + " times");
    }
    newDuration = {};
    newDuration[timestamp] = responseRecord;
    durationsObject['durations'].push(newDuration);
    durationsObject['lastDurations'] = durationsObject['durations'].slice(-NUM_OF_LAST_DURATIONS);
    lastDurations = durationsObject['lastDurations'];
    sumDurations = 0;
    countDurations = 0;
    for (i = 0, len = lastDurations.length; i < len; i++) {
      durationObject = lastDurations[i];
      for (timestamp in durationObject) {
        responseRecord = durationObject[timestamp];
        if (responseRecord['time']) {
          sumDurations += responseRecord['time'];
          countDurations++;
        }
      }
    }
    durationsObject['lastDurationsAverage'] = sumDurations / countDurations;
    allDurations.update({
      _id: durationsObject['_id']
    }, durationsObject);
    variance = currentDuration / durationsObject['lastDurationsAverage'];
    metricStrings = ['duration', 'variance'];
    metricValues = [currentDuration, variance];
    metrics = db.get('metrics');
    return [0, 1].map(function(metricIndex) {
      var metricString, metricValue;
      metricString = metricStrings[metricIndex];
      metricValue = metricValues[metricIndex];
      return metrics.findOne({
        metric: metricString
      }, function(error, recordsObject) {
        var newRecord;
        if (error) {
          console.log('ERROR: the database could not be updated');
          return;
        }
        newRecord = {
          url: url,
          type: requestType
        };
        newRecord[metricString] = metricValue;
        recordsObject['records'].push(newRecord);

        /*
        Use the snippet below if it is needed to store top X URLs in the
        performance dashboard, instead of storing all like we currently do.
        The snippet below would replace the three lines above.
        ______________________________________________________________________
        min = recordsObject['min']
        newRecord = { url: url, type: requestType }
        newRecord[metricString] = metricValue
        if (recordsObject['records'].length < NUM_OF_MOST_EXTREME and
            metricValue)
          recordsObject['records'].push newRecord
          if min > metricValue
            recordsObject['min'] = metricValue
        else
          if min < metricValue
            newMin = MAX_VALUE
            for record, index in recordsObject['records']
              if record[metricString] is min
                recordsObject['records'][index] = newRecord
              if newMin > recordsObject['records'][index][metricString]
                newMin = recordsObject['records'][index][metricString]
            recordsObject['min'] = newMin
         */
        return metrics.update({
          _id: recordsObject['_id']
        }, recordsObject);
      });
    });
  });
  durationsByTimestamp = db.get('durationsByTimestamp');
  return durationsByTimestamp.findOne({
    timestamp: timestamp
  }, function(error, durationsObject) {
    if (error) {
      console.log('ERROR: the database could be updated');
      return;
    }
    if (!durationsObject) {
      durationsObject = {
        timestamp: timestamp,
        durations: []
      };
    }
    durationsObject['durations'].push(responseRecord);
    if (durationsObject['_id']) {
      return durationsByTimestamp.update({
        _id: durationsObject['_id']
      }, durationsObject);
    } else {
      return durationsByTimestamp.insert(durationsObject);
    }
  });
};

findMedianRecord = function(responseRecords) {
  var middle;
  responseRecords.sort(function(a, b) {
    return a.time - b.time;
  });
  middle = Math.floor(responseRecords.length / 2);
  return responseRecords[middle];
};
